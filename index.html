<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>별똥별 잡기</title>
  <style>
    /* 기본 레이아웃 */
    :root{ --bg:#071129; --panel:#0f2440; --accent:#ffd24a }
    html,body{ height:100%; margin:0; font-family: 'Segoe UI', Roboto, 'Noto Sans KR', sans-serif; background:linear-gradient(180deg,var(--bg),#051023); color:#fff }
    .wrap{ min-height:100%; display:flex; align-items:center; justify-content:center; gap:24px; padding:36px }
    .card{ background:linear-gradient(180deg,var(--panel),#092033); border-radius:12px; padding:14px; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
    canvas{ display:block; background: radial-gradient(1200px 600px at 10% 10%, rgba(255,255,255,0.02), transparent), url('') ; border-radius:8px }
    .ui{ display:flex; gap:12px; align-items:center }
    .info{ display:flex; gap:12px; align-items:center; }
    .btn{ background:transparent; border:1px solid rgba(255,255,255,0.08); padding:8px 12px; border-radius:8px; cursor:pointer; color:#fff }
    .btn:hover{ transform:translateY(-2px) }
    .big{ font-weight:700; font-size:18px }
    .small{ font-size:13px; color:rgba(255,255,255,0.7) }
    @media (max-width:600px){ .wrap{ padding:16px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card" style="width:760px;">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px">
        <div>
          <div class="big">별똥별 잡기 🌠</div>
          <div class="small">화살표 키(← →) 또는 A/D로 이동하세요. 모바일은 화면 터치로 이동.</div>
        </div>
        <div class="ui">
          <div class="info">
            <div class="small">점수</div>
            <div id="score" class="big" style="margin-left:8px">0</div>
          </div>
          <div class="info">
            <div class="small">목숨</div>
            <div id="lives" class="big" style="margin-left:8px">3</div>
          </div>
          <button id="startBtn" class="btn">시작</button>
          <button id="restartBtn" class="btn">초기화</button>
        </div>
      </div>

      <canvas id="gameCanvas" width="720" height="400"></canvas>

      <div class="small" style="margin-top:10px; color:rgba(255,255,255,0.7)">
        설명: 떨어지는 별을 바구니로 받으면 점수 +1. 바닥에 떨어지면 목숨 -1. 난이도는 시간이 지날수록 증가합니다.
      </div>
    </div>
  </div>

<script>
// 별똥별 잡기 - 단일 파일 구현
// 작성: ChatGPT

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');

let game = null;

class Player {
  constructor(){
    this.width = 100;
    this.height = 18;
    this.x = (canvas.width - this.width)/2;
    this.y = canvas.height - this.height - 8;
    this.speed = 6;
    this.color = '#ffd24a';
  }
  move(dir){
    this.x += dir * this.speed;
    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
  }
  draw(){
    // 바구니 모양
    ctx.fillStyle = this.color;
    roundRect(ctx, this.x, this.y, this.width, this.height, 8, true, false);
    // 장식
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(this.x + 8, this.y + 3, this.width - 16, 2);
  }
}

class Star {
  constructor(x,y,vy,sz){
    this.x = x; this.y = y; this.vy = vy; this.size = sz; this.caught = false; 
    this.angle = Math.random() * Math.PI * 2; // 회전 장식
  }
  update(dt){
    this.y += this.vy * dt;
    this.angle += 0.04;
  }
  draw(){
    // 단순한 별 그리기
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.beginPath();
    for(let i=0;i<5;i++){
      ctx.lineTo(0, -this.size);
      ctx.rotate(Math.PI/5);
      ctx.lineTo(0, -this.size/2);
      ctx.rotate(Math.PI/5);
    }
    ctx.closePath();
    ctx.fillStyle = '#fff4c9';
    ctx.fill();
    ctx.restore();
  }
}

function roundRect(ctx, x, y, w, h, r, fill, stroke) {
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

class Game {
  constructor(){
    this.player = new Player();
    this.stars = [];
    this.score = 0;
    this.lives = 3;
    this.elapsed = 0; // 경과 시간
    this.spawnTimer = 0;
    this.spawnInterval = 1000; // ms
    this.running = false;
    this.last = 0;
    this.inputDir = 0;

    // 입력
    this.keys = {};
    window.addEventListener('keydown', e => { this.keys[e.key] = true; });
    window.addEventListener('keyup', e => { this.keys[e.key] = false; });

    // 터치 / 마우스 이동 (모바일 친화적)
    canvas.addEventListener('pointerdown', e => this.onPointer(e));
    canvas.addEventListener('pointermove', e => { if(e.pressure>0 || e.buttons) this.onPointer(e); });

    // 리사이즈 고려 (고정 크기이라서 생략 가능)
  }

  start(){
    this.reset();
    this.running = true;
    this.last = performance.now();
    requestAnimationFrame(t => this.frame(t));
  }
  reset(){
    this.stars = [];
    this.score = 0;
    this.lives = 3;
    this.elapsed = 0;
    this.spawnTimer = 0;
    this.spawnInterval = 1000;
    scoreEl.textContent = this.score;
    livesEl.textContent = this.lives;
  }
  stop(){ this.running = false; }

  onPointer(e){
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    // 포인터로 플레이어 중앙 맞추기
    this.player.x = Math.max(0, Math.min(canvas.width - this.player.width, x - this.player.width/2));
  }

  spawnStar(){
    const x = Math.random() * (canvas.width - 30) + 15;
    const size = 8 + Math.random() * 10;
    // 난이도에 따라 속도 증가
    const speed = 60 + Math.random()*60 + (this.elapsed/1000) * 6;
    this.stars.push(new Star(x, -20, speed/1000, size));
  }

  update(dt){
    // 키 입력 처리 (A,D, 좌우)
    let dir = 0;
    if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) dir -= 1;
    if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) dir += 1;
    this.player.move(dir);

    // 자동 난이도: 시간 지날수록 spawn 빠르게
    this.spawnTimer += dt*1000;
    const intervalTarget = Math.max(300, this.spawnInterval - (this.elapsed/1000)*40);
    if (this.spawnTimer > intervalTarget){
      this.spawnTimer = 0;
      this.spawnStar();
    }

    // 별 업데이트
    for(let s of this.stars) s.update(dt);

    // 충돌 검사(플레이어 바구니)
    for(let i = this.stars.length-1; i>=0; i--){
      const s = this.stars[i];
      if (s.y > canvas.height + 30){
        // 바닥에 떨어지면 목숨 감소
        this.stars.splice(i,1);
        this.lives -= 1;
        livesEl.textContent = this.lives;
        if (this.lives <= 0){ this.running = false; }
        continue;
      }
      // 단순 AABB 충돌: 별이 플레이어 영역 안에 들어오면 잡음
      if (s.x > this.player.x - s.size && s.x < this.player.x + this.player.width + s.size
          && s.y + s.size > this.player.y){
        this.stars.splice(i,1);
        this.score += 1;
        scoreEl.textContent = this.score;
      }
    }

    this.elapsed += dt*1000;
  }

  draw(){
    // 배경별
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // 밤하늘 그라디언트
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#071129'); g.addColorStop(1,'#02101b');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    // 작은 별 여러개 (장식)
    for(let i=0;i<30;i++){
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      ctx.fillRect((i*97)%canvas.width, (i*53)%canvas.height, 2,2);
    }

    // 플레이어
    this.player.draw();

    // 별 그리기
    for(let s of this.stars) s.draw();

    // 게임오버 텍스트
    if (!this.running && this.lives <= 0){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.font = '28px sans-serif';
      ctx.fillText('게임 오버', canvas.width/2, canvas.height/2 - 10);
      ctx.font = '16px sans-serif';
      ctx.fillText('초기화를 눌러 다시 시작하세요', canvas.width/2, canvas.height/2 + 18);
    }
  }

  frame(ts){
    if (!this.running) return this.draw();
    const dt = Math.min(0.05, (ts - this.last)/1000); // 안정성
    this.update(dt);
    this.draw();
    this.last = ts;
    requestAnimationFrame(t => this.frame(t));
  }
}

// 초기화
function init(){
  game = new Game();
  // 버튼 바인딩
  startBtn.addEventListener('click', ()=>{
    if (!game.running) game.start();
  });
  restartBtn.addEventListener('click', ()=>{
    game.reset();
    if (!game.running) { game.draw(); }
  });

  // 처음 화면 렌더
  game.draw();
}

init();
</script>
</body>
</html>
